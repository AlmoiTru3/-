# Перейди в корневую папку проекта (где лежат lab2.cpp, main.cpp)
cd ~/Lab2/os-task2-AlnoiTrua

# Запусти тесты из корневой директории
g++ lab2.cpp test/tests.cpp -lpthread -lgtest -o runTests -I test/gtest/include -L test/gtest



g++ ../lab2.cpp tests.cpp -lpthread -lgtest -o runTests -I gtest/include -L gtest
ааааааааааааааааааааа
cd test/gtest
GTEST_DIR=$(pwd)
g++ -isystem "${GTEST_DIR}"/include -I"${GTEST_DIR}" -pthread -c "${GTEST_DIR}"/src/gtest-all.cc 
ar -rv libgtest.a gtest-all.o
ААААААААААААААААААААААААААААААААААААААААА
#include "lab2.h"
#include <iostream>
#include <pthread.h>
#include <semaphore.h>
#include <cstring>
// Объявляем всё необходимое
pthread_mutex_t print_mutex;
pthread_t threads[8]; // a,b,c,d1,d2,e,f,g - индексы: 0=a,1=b,2=c,3=d1,4=d2,5=e,6=f,7=g

// Семафоры для синхронизации b,c,d
sem_t sem_b, sem_c, sem_d;

// Функции потоков
void* thread_a(void* arg);
void* thread_b(void* arg);
void* thread_c(void* arg);
void* thread_d_part1(void* arg); // d в первой группе (bcd)
void* thread_d_part2(void* arg); // d во второй группе (deg)
void* thread_e(void* arg);
void* thread_f(void* arg);
void* thread_g(void* arg);

unsigned int lab2_thread_graph_id() {
    return 6;  // Граф №6 для варианта 2
}

const char* lab2_unsynchronized_threads() {
    return "deg";  // Потоки без синхронизации
}

const char* lab2_sequential_threads() {
    return "bcd";  // Потоки с чередованием
}

// Поток a - работает первый, один
void* thread_a(void* arg) {
    int iterations = 4; // 4 итерации (коэффициент 4 × длина 1)
    
    for (int i = 0; i < iterations; ++i) {
        pthread_mutex_lock(&print_mutex);
        std::cout << "a" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        computation();
    }
    return nullptr;
}

// Поток b - синхронизированный с c и d
void* thread_b(void* arg) {
    int iterations = 8; // 4 × длина 2
    
    for (int i = 0; i < iterations; ++i) {
        sem_wait(&sem_b); // Жду разрешения
        
        pthread_mutex_lock(&print_mutex);
        std::cout << "b" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        
        computation();
        
        sem_post(&sem_c); // Разрешаю c работать
    }
    return nullptr;
}

// Поток c - синхронизированный с b и d
void* thread_c(void* arg) {
    int iterations = 8; // 4 × длина 2
    
    for (int i = 0; i < iterations; ++i) {
        sem_wait(&sem_c); // Жду разрешения
        
        pthread_mutex_lock(&print_mutex);
        std::cout << "c" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        
        computation();
        
        sem_post(&sem_d); // Разрешаю d работать
    }
    return nullptr;
}

// Поток d в первой группе (синхронизированный с b и c)
void* thread_d_part1(void* arg) {
    int iterations = 8; // 4 × длина 2
    
    for (int i = 0; i < iterations; ++i) {
        sem_wait(&sem_d); // Жду разрешения
        
        pthread_mutex_lock(&print_mutex);
        std::cout << "d" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        
        computation();
        
        sem_post(&sem_b); // Разрешаю b работать (замыкаем круг)
    }
    return nullptr;
}

// Поток d во второй группе (несинхронизированный с e и g)
void* thread_d_part2(void* arg) {
    int iterations = 4; // 4 × длина 1
    
    for (int i = 0; i < iterations; ++i) {
        pthread_mutex_lock(&print_mutex);
        std::cout << "d" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        computation();
    }
    return nullptr;
}

// Поток e - несинхронизированный с d и g
void* thread_e(void* arg) {
    int iterations = 4; // 4 × длина 1
    
    for (int i = 0; i < iterations; ++i) {
        pthread_mutex_lock(&print_mutex);
        std::cout << "e" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        computation();
    }
    return nullptr;
}

// Поток f - работает последний, один
void* thread_f(void* arg) {
    int iterations = 4; // 4 × длина 1
    
    for (int i = 0; i < iterations; ++i) {
        pthread_mutex_lock(&print_mutex);
        std::cout << "f" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        computation();
    }
    return nullptr;
}

// Поток g - несинхронизированный с d и e
void* thread_g(void* arg) {
    int iterations = 4; // 4 × длина 1
    
    for (int i = 0; i < iterations; ++i) {
        pthread_mutex_lock(&print_mutex);
        std::cout << "g" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        computation();
    }
    return nullptr;
}

int lab2_init() {
    int err;
    
    // Инициализация мьютекса для защиты вывода
    if (pthread_mutex_init(&print_mutex, NULL) != 0) {
        std::cerr << "Mutex init failed" << std::endl;
        return 1;
    }
    
    // Инициализация семафоров для синхронизации b,c,d
    // sem_b начинается с 1 - поток b стартует первым
    if (sem_init(&sem_b, 0, 1) != 0) {
        std::cerr << "Semaphore B init failed" << std::endl;
        return 1;
    }
    // sem_c и sem_d начинаются с 0 - ждут разрешения
    if (sem_init(&sem_c, 0, 0) != 0) {
        std::cerr << "Semaphore C init failed" << std::endl;
        return 1;
    }
    if (sem_init(&sem_d, 0, 0) != 0) {
        std::cerr << "Semaphore D init failed" << std::endl;
        return 1;
    }

    // ЭТАП 1: Поток a (работает один)
    std::cout << "=== Этап 1: Поток a ===" << std::endl;
    err = pthread_create(&threads[0], NULL, thread_a, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread A. Error: " << strerror(err) << std::endl;
        return 1;
    }
    pthread_join(threads[0], NULL); // Ждём завершения a
    
    // ЭТАП 2: Синхронизированные потоки b, c, d (чередуются)
    std::cout << "\n=== Этап 2: Синхронизированные b, c, d ===" << std::endl;
    err = pthread_create(&threads[1], NULL, thread_b, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread B. Error: " << strerror(err) << std::endl;
        return 1;
    }
    err = pthread_create(&threads[2], NULL, thread_c, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread C. Error: " << strerror(err) << std::endl;
        return 1;
    }
    err = pthread_create(&threads[3], NULL, thread_d_part1, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread D1. Error: " << strerror(err) << std::endl;
        return 1;
    }
    
    // Ждём завершения всех трёх синхронизированных потоков
    pthread_join(threads[1], NULL);
    pthread_join(threads[2], NULL);
    pthread_join(threads[3], NULL);
    
    // ЭТАП 3: Несинхронизированные потоки d, e, g (работают параллельно)
    std::cout << "\n=== Этап 3: Несинхронизированные d, e, g ===" << std::endl;
    err = pthread_create(&threads[4], NULL, thread_d_part2, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread D2. Error: " << strerror(err) << std::endl;
        return 1;
    }
    err = pthread_create(&threads[5], NULL, thread_e, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread E. Error: " << strerror(err) << std::endl;
        return 1;
    }
    err = pthread_create(&threads[7], NULL, thread_g, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread G. Error: " << strerror(err) << std::endl;
        return 1;
    }
    
    // Ждём завершения всех трёх несинхронизированных потоков
    pthread_join(threads[4], NULL);
    pthread_join(threads[5], NULL);
    pthread_join(threads[7], NULL);
    
    // ЭТАП 4: Поток f (работает один)
    std::cout << "\n=== Этап 4: Поток f ===" << std::endl;
    err = pthread_create(&threads[6], NULL, thread_f, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread F. Error: " << strerror(err) << std::endl;
        return 1;
    }
    pthread_join(threads[6], NULL); // Ждём завершения f
    
    // Освобождение ресурсов
    pthread_mutex_destroy(&print_mutex);
    sem_destroy(&sem_b);
    sem_destroy(&sem_c);
    sem_destroy(&sem_d);
    
    std::cout << "\n=== Программа завершена ===" << std::endl;
    return 0;
}

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
#include "lab2.h"
#include <iostream>
#include <pthread.h>
#include <semaphore.h>
#include <cstring>

// Объявляем всё необходимое
pthread_mutex_t print_mutex;
pthread_t threads[8]; // 0=a,1=b,2=c,3=d1,4=d2,5=e,6=f,7=g

// Семафоры для синхронизации b,c,d
sem_t sem_b, sem_c, sem_d;

// Функции потоков
void* thread_a(void* arg);
void* thread_b(void* arg);
void* thread_c(void* arg);
void* thread_d_part1(void* arg);
void* thread_d_part2(void* arg);
void* thread_e(void* arg);
void* thread_f(void* arg);
void* thread_g(void* arg);

unsigned int lab2_thread_graph_id() {
    return 6;
}

const char* lab2_unsynchronized_threads() {
    return "deg";
}

const char* lab2_sequential_threads() {
    return "bcd";
}

// Поток a - работает первый, один
void* thread_a(void* arg) {
    int iterations = 4;
    
    for (int i = 0; i < iterations; ++i) {
        pthread_mutex_lock(&print_mutex);
        std::cout << "a" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        computation();
    }
    return nullptr;
}

// Поток b - синхронизированный с c и d
void* thread_b(void* arg) {
    int iterations = 8;
    
    for (int i = 0; i < iterations; ++i) {
        sem_wait(&sem_b);
        
        pthread_mutex_lock(&print_mutex);
        std::cout << "b" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        
        computation();
        
        sem_post(&sem_c);
    }
    return nullptr;
}

// Поток c - синхронизированный с b и d
void* thread_c(void* arg) {
    int iterations = 8;
    
    for (int i = 0; i < iterations; ++i) {
        sem_wait(&sem_c);
        
        pthread_mutex_lock(&print_mutex);
        std::cout << "c" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        
        computation();
        
        sem_post(&sem_d);
    }
    return nullptr;
}

// Поток d в первой группе (синхронизированный с b и c)
void* thread_d_part1(void* arg) {
    int iterations = 8;
    
    for (int i = 0; i < iterations; ++i) {
        sem_wait(&sem_d);
        
        pthread_mutex_lock(&print_mutex);
        std::cout << "d" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        
        computation();
        
        sem_post(&sem_b);
    }
    return nullptr;
}

// Поток d во второй группе (несинхронизированный с e и g)
void* thread_d_part2(void* arg) {
    int iterations = 4;
    
    for (int i = 0; i < iterations; ++i) {
        pthread_mutex_lock(&print_mutex);
        std::cout << "d" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        computation();
    }
    return nullptr;
}

// Поток e - несинхронизированный с d и g
void* thread_e(void* arg) {
    int iterations = 4;
    
    for (int i = 0; i < iterations; ++i) {
        pthread_mutex_lock(&print_mutex);
        std::cout << "e" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        computation();
    }
    return nullptr;
}

// Поток f - работает последний, один
void* thread_f(void* arg) {
    int iterations = 4;
    
    for (int i = 0; i < iterations; ++i) {
        pthread_mutex_lock(&print_mutex);
        std::cout << "f" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        computation();
    }
    return nullptr;
}

// Поток g - несинхронизированный с d и e
void* thread_g(void* arg) {
    int iterations = 4;
    
    for (int i = 0; i < iterations; ++i) {
        pthread_mutex_lock(&print_mutex);
        std::cout << "g" << std::flush;
        pthread_mutex_unlock(&print_mutex);
        computation();
    }
    return nullptr;
}

int lab2_init() {
    int err;
    
    // Инициализация мьютекса для защиты вывода
    if (pthread_mutex_init(&print_mutex, NULL) != 0) {
        std::cerr << "Mutex init failed" << std::endl;
        return 1;
    }
    
    // Инициализация семафоров для синхронизации b,c,d
    if (sem_init(&sem_b, 0, 1) != 0) {
        std::cerr << "Semaphore B init failed" << std::endl;
        return 1;
    }
    if (sem_init(&sem_c, 0, 0) != 0) {
        std::cerr << "Semaphore C init failed" << std::endl;
        return 1;
    }
    if (sem_init(&sem_d, 0, 0) != 0) {
        std::cerr << "Semaphore D init failed" << std::endl;
        return 1;
    }

    // ЭТАП 1: Поток a
    err = pthread_create(&threads[0], NULL, thread_a, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread A. Error: " << strerror(err) << std::endl;
        return 1;
    }
    pthread_join(threads[0], NULL);
    
    // ЭТАП 2: Синхронизированные потоки b, c, d
    err = pthread_create(&threads[1], NULL, thread_b, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread B. Error: " << strerror(err) << std::endl;
        return 1;
    }
    err = pthread_create(&threads[2], NULL, thread_c, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread C. Error: " << strerror(err) << std::endl;
        return 1;
    }
    err = pthread_create(&threads[3], NULL, thread_d_part1, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread D1. Error: " << strerror(err) << std::endl;
        return 1;
    }
    
    pthread_join(threads[1], NULL);
    pthread_join(threads[2], NULL);
    pthread_join(threads[3], NULL);
    
    // ЭТАП 3: Несинхронизированные потоки d, e, g
    err = pthread_create(&threads[4], NULL, thread_d_part2, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread D2. Error: " << strerror(err) << std::endl;
        return 1;
    }
    err = pthread_create(&threads[5], NULL, thread_e, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread E. Error: " << strerror(err) << std::endl;
        return 1;
    }
    err = pthread_create(&threads[7], NULL, thread_g, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread G. Error: " << strerror(err) << std::endl;
        return 1;
    }
    
    pthread_join(threads[4], NULL);
    pthread_join(threads[5], NULL);
    pthread_join(threads[7], NULL);
    
    // ЭТАП 4: Поток f
    err = pthread_create(&threads[6], NULL, thread_f, NULL);
    if (err != 0) {
        std::cerr << "Can't create thread F. Error: " << strerror(err) << std::endl;
        return 1;
    }
    pthread_join(threads[6], NULL);
    
    // Освобождение ресурсов
    pthread_mutex_destroy(&print_mutex);
    sem_destroy(&sem_b);
    sem_destroy(&sem_c);
    sem_destroy(&sem_d);
    
    return 0;
}
